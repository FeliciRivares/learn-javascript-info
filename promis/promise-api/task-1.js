// Promise.all приймає ітеративний об’єкт (зазвичай масив промісів) і повертає новий проміс.
// Новий проміс завершиться тоді, коли всі перераховані проміси завершаться, а його результатом стане масив їхніх результатів.
// Наприклад, нижченаведений Promise.all виконається через 3 секунди, а потім його результатом буде масив [1, 2, 3]:

Promise.all([
    new Promise(resolve => setTimeout(() => resolve(1), 3000)), // 1
    new Promise(resolve => setTimeout(() => resolve(2), 2000)), // 2
    new Promise(resolve => setTimeout(() => resolve(3), 1000))  // 3
  ]).then(alert); 
  
// коли всі проміси виконаються, результат буде 1,2,3: кожен проміс надає елемент масиву
// Будь ласка, зверніть увагу, що порядок елементів масиву такий самий, як у вихідних промісах. Навіть якщо для завершення першого проміса потрібно буде найбільше часу, його результат все одно буде першим в масиві.
// Поширений трюк – пропустити масив даних через map-функцію, яка для кожного елемента створить задачу-проміс, а потім загорне отриманий результат в Promise.all.

// Якщо будь-який з промісів завершується з помилкою, то проміс, що поверне Promise.all, негайно завершиться з цією ж помилкою.

// Наприклад:

Promise.all([
  new Promise((resolve, reject) => setTimeout(() => resolve(1), 1000)),
  new Promise((resolve, reject) => setTimeout(() => reject(new Error("Упс!")), 2000)),
  new Promise((resolve, reject) => setTimeout(() => resolve(3), 3000))
]).catch(alert); // Error: Упс!

// Тут другий проміс завершиться з помилкою через дві секунди. Це призведе до негайної помилки в Promise.all, тому виконається .catch: помилка цього проміса стає результатом всього Promise.all.

// У разі помилки інші проміси ігноруються
// Якщо один проміс завершується з помилкою, то весь Promise.all негайно завершується з нею ж, повністю забувши про інші проміси у списку. Їх результати ігноруються.

// Наприклад, якщо є кілька викликів fetch, як у наведеному вище прикладі, і один з них не виконався, інші продовжуватимуть виконуватися, але Promise.all більше не переглядатиме їх. Ймовірно, вони так чи інакше завершаться, але їхні результати будуть проігноровані.

// Promise.all не робить нічого для їх скасування, оскільки в обіцянках немає поняття “скасування”. У главі Fetch: переривання запиту ми розглянемо AbortController, який може допомогти з цим, але він не є частиною Promise API.

// Promise.all(iterable) дозволяє передавати не-проміси в iterable (об’єкт, що перебирається)
// Зазвичай Promise.all(...) приймає ітераційний об’єкт промісів (у більшості випадків масив). Але якщо будь-який з цих об’єктів не є промісом, він передається в результуючий масив «як є».

// Promise.allSettled просто чекає, коли всі проміси завершаться, незалежно від результату. В отриманому масиві буде:

// {status:"fulfilled", value:result} для успішних відповідей,
// {status:"rejected", reason:error} для помилок.
// Наприклад, ми хочемо отримати інформацію про кількох користувачів. Навіть якщо один запит не вдасться, ми все одно зацікавлені в інших.

// Використаємо для цього Promise.allSettled:

let urls = [
  'https://api.github.com/users/iliakan',
  'https://api.github.com/users/remy',
  'https://no-such-url'
];

Promise.allSettled(urls.map(url => fetch(url)))
  .then(results => { // (*)
    results.forEach((result, num) => {
      if (result.status == "fulfilled") {
        alert(`${urls[num]}: ${result.value.status}`);
      }
      if (result.status == "rejected") {
        alert(`${urls[num]}: ${result.reason}`);
      }
    });
  });
// Масив results у рядку (*) буде таким:

[
  {status: 'fulfilled', value: result/* ...об’єкт відповіді... */},
  {status: 'fulfilled', value: result /* ...об’єкт відповіді... */ },
  {status: 'rejected', reason: result /* ...об’єкт помилки... */}
]
// Тож для кожного проміса ми отримуємо його статус і value/error.

// Promise.race
// Подібний до Promise.all, але чекає лише на перший виконаний проміс та отримує його результат (або помилку).
// Синтаксис:

let promiseRace = Promise.race(iterable);
// Найшвидшим тут був перший проміс, тому він і став результатом. Після того, як перший виконаний проміс «перемагає», всі подальші результати/помилки ігноруються.

// Promise.any
// Схожий на Promise.race, але чекає лише на перший успішно виконаний проміс і отримує його результат. Якщо ж всі надані проміси завершуються з помилкою, то повертається проміс, що завершується з помилкою за допомогою AggregateError – спеціального об’єкта помилки, який зберігає всі помилки промісів у своїй властивості errors.

// Синтаксис:

let promiseAny = Promise.any(iterable);

// Перший проміс тут був найшвидшим, але завершився з помилкою, тож результатом став другий проміс. Після того, як перший виконаний проміс «перемагає», усі подальші результати ігноруються.

// Promise.resolve/reject
// Методи Promise.resolve і Promise.reject рідко потрібні в сучасному коді, тому що синтаксис async/await (ми розглянемо його трохи пізніше) робить їх дещо застарілими.

// Підсумки
// Існує 6 статичних методів класу Promise:

// Promise.all(promises) – чекає виконання всіх промісів і повертає масив їх результатів. Якщо будь-який з наданих промісів завершується з помилкою, вона стає загальною для Promise.all, а всі інші результати ігноруються.

// Promise.allSettled(promises) (нещодавно доданий метод) – чекає завершення всіх промісів і повертає їх результати у вигляді масиву об’єктів, до якого входять:
// status: "fulfilled" або "rejected"
// value (якщо виконано успішно) або reason (якщо помилка).

// Promise.race(promises) – чекає виконання першого проміса, а його результат/помилка стає остаточним результатом.

// Promise.any(promises) (нещодавно доданий метод) – чекає виконання першого проміса, а його результат стає остаточним результатом. Якщо всі надані проміси завершуються з помилкою, AggregateError стає загальною помилкою Promise.any.

// Promise.resolve(value) – повертає успішно виконаний проміс із заданим значенням.

// Promise.reject(error) – повертає проміс із заданою помилкою.
// З усіх цих методів Promise.all, мабуть, найпоширеніший на практиці.