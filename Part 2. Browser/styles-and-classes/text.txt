Методи classList:

elem.classList.add/remove("class") – додати/видалити клас.
elem.classList.toggle("class") – додає клас, якщо він не існує, а інакше – видаляє його.
elem.classList.contains("class") – перевіряє, чи переданий клас існує, відповідно повертає true/false.
Крім того, classList – це ітерований об’єкт, тому можна легко вивести перелік всіх класів циклом for..of, як показано далі:

<body class="main page">
  <script>
    for (let name of document.body.classList) {
      alert(name); // main, а за ним page
    }
  </script>
</body>


Зазвичай, style.* використовується для встановлення окремих властивостей стилю. Немає можливості задати весь стиль, як от div.style="color: red; width: 100px", оскільки div.style – це об’єкт, і він придатний лише для читання.

Існує спеціальна властивість style.cssText, яка дає змогу встановлювати повний стиль елемента як рядок:

<div id="div">Кнопка</div>

<script>
  // тут можна встановити такі спеціальні прапорці стилю, як "important"
  div.style.cssText=`color: red !important;
    background-color: yellow;
    width: 100px;
    text-align: center;
  `;

  alert(div.style.cssText);
</script>
Ця властивість рідко використовується, оскільки присвоєння стилів у такий спосіб видаляє всі наявні стилі: тобто воно не додає стилі, а радше заміняє їх. Може випадково видалити щось важливе. Однак можна спокійно використовувати її для нових елементів, коли наперед відомо, що там немає ніяких наявних стилів, які можна було б випадково видалити.

Того самого можна досягнути шляхом встановлення значення атрибута: div.setAttribute('style', 'color: red...').


Властивість style працює лише зі значенням атрибута "style", без врахування каскадності CSS.

Тобто за допомогою elem.style неможливо прочитати щось, що прийшло з CSS-класів.


Але що робити, якщо ми хочемо, скажімо, збільшити розмір зовнішнього відступу на 20px? Для цього нам потрібно знати актуальне значення.

Для цього існує інший метод, а саме – getComputedStyle.

Синтаксис виглядає так:

getComputedStyle(element, [pseudo])
element
Елемент, значення властивості якого потрібно прочитати.
pseudo
Вказується, якщо потрібен стиль псевдоелемента, наприклад: ::before. Порожній рядок, або опущений аргумент означатимуть, що буде опрацьовано сам елемент.
В результаті виклику методу буде повернено об’єкт зі стилями, подібно до elem.style, але зі врахуванням всіх класів CSS.


getComputedStyle вимагає повної назви властивості
Слід завжди запитувати точну назву властивості, значення якої потрібно отримати, як paddingLeft, marginTop чи borderTopWidth. Інакше коректний результат не гарантовано.

Наприклад, якщо на елементі задано властивості paddingLeft/paddingTop, що ми отримаємо, запитавши значення getComputedStyle(elem).padding? Нічого, чи може якесь “згенероване” значення наявних полів? Тут немає жодного стандартного правила.

Також існують інші непослідовності. Для прикладу, деякі браузери (Chrome) покажуть 10px в документі, наведеному нижче, а інші (Firefox) – цього не зроблять:

<style>
  body {
    margin: 10px;
  }
</style>
<script>
  let style = getComputedStyle(document.body);
  alert(style.margin); // порожній рядок у Firefox
</script>