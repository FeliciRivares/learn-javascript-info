
Ідея в тому, що якщо у нас є багато елементів, які обробляються подібним чином, то замість того, щоб призначати обробник кожному з них, ми ставимо один обробник на їхнього спільного предка.

У обробнику ми отримуємо event.target, щоб побачити, де насправді сталася подія і обробити її


Завжди використовуйте метод addEventListener для обробників на рівні документу
Коли ми присвоюємо обробник події об’єкту document, ми завжди повинні використовувати addEventListener, а не document.on<event>, оскільки останній спричинить конфлікти: нові обробники перезапишуть старі.

Для реальних проєктів вважається нормальною наявність великої кількості обробників на document, встановлених різними частинами коду.



Алгоритм:

Додайте один обробник на контейнер.
У обробнику – перевірте вихідний елемент event.target.
Якщо подія відбулася всередині елемента, який нас цікавить, обробіть подію.
Переваги:

Спрощує ініціалізацію та економить пам’ять: не потрібно додавати багато обробників.
Менше коду: під час додавання або видалення елементів не потрібно додавати/видаляти обробники.
Модифікації DOM: ми можемо масово додавати/видаляти елементи за допомогою innerHTML тощо.
Звичайно, делегування має свої обмеження:

По-перше, подія повинна спливати. Деякі події не спливають. Крім того, низькорівневі обробники не повинні використовувати event.stopPropagation().
По-друге, делегування може збільшити навантаження на центральний процесор, оскільки обробник на рівні контейнера реагує на події в будь-якому місці контейнера, незалежно від того, цікавлять вони нас чи ні. Але зазвичай навантаження незначне, тому ми не беремо його до уваги.