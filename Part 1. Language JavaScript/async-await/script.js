async function f() {
    return 1;
  }
// Слово async перед функцією означає одну просту річ: функція завжди повертає проміс. Інші значення автоматично загортаються в успішно виконаний проміс.

// працює лише всередині async-функцій
let value = await promise;
// Ключове слово await змушує JavaScript чекати, поки проміс не виконається, та повертає його результат.

// Щоб оголосити асинхронний метод класу, просто додайте перед ним async:

class Waiter {
  async wait() {
    return await Promise.resolve(1);
  }
}

new Waiter()
  .wait()
  .then(alert); // 1 (це те ж саме, що й (result => alert(result)))
// Сенс той самий: це гарантує, що повернуте значення буде промісом, і дозволяє використовувати await.

// Коли ми використовуємо async/await, нам рідко потрібен .then, тому що await обробляє очікування за нас. І ми можемо використовувати звичайний try..catch замість .catch. Зазвичай (але не завжди) це зручніше.

// Але на верхньому рівні вкладеності коду, коли ми знаходимося за межами будь-якої функції async, ми синтаксично не можемо використовувати await, тому звичайна практика – додати .then/catch для обробки кінцевого результату або помилки, що була повернута, як у рядку “(*)” у прикладі вище.

// async/await чудово працює з Promise.all
// Коли нам потрібно дочекатися кількох промісів, ми можемо загорнути їх у Promise.all, а потім додати await:

// чекаємо масив результатів
let results = await Promise.all([
  fetch(url1),
  fetch(url2),
]);
// У разі помилки вона передаватиметься як зазвичай: від невдалого проміса до Promise.all, а потім стає винятком, який ми можемо зловити за допомогою try..catch навколо виклику.

// Підсумки
// Ключове слово async перед функцією має два ефекти:

// Змушує її завжди повертати проміс.
// Дозволяє використовувати в ній await.
// Ключове слово await перед промісом змушує JavaScript чекати, поки цей проміс не виконається, а потім:

// Якщо це помилка, генерується виняток — так само, ніби throw error було викликано саме в цьому місці.
// В іншому випадку він повертає результат.
// Разом вони забезпечують чудову структуру для написання асинхронного коду, який легко і читати, і писати.

// За допомогою async/await нам рідко потрібно писати promise.then/catch, але ми все одно не повинні забувати, що вони засновані на промісах, тому що іноді (наприклад, на верхньому рівні вкладеності) нам доводиться використовувати ці методи. Також Promise.all стає в нагоді, коли ми чекаємо на виконання багатьох завдань одночасно.