// Ланцюги промісів чудово підходять для обробки помилок. Якщо проміс завершує своє виконання з помилкою, то управління переходить в найближчий обробник помилок. На практиці, це дуже зручно.

// Наприклад, в наведеному нижче прикладі для fetch вказане неправильне посилання (такого сайту не існує), і .catch перехоплює помилку:

fetch('https://no-such-server.blabla') // помилка
  .then(response => response.json())
  .catch(err => alert(err)) // TypeError: failed to fetch (текст може відрізнятися)

//Якщо відбувається помилка, і відсутній її обробник, то генерується подія unhandledrejection, і відповідний об’єкт event містить інформацію про помилку.

// Зазвичай такі помилки невідворотні, тому краще всього – інформувати користувача про проблему і, можливо, відправити інформацію про помилку на сервер.




// .catch перехоплює усі види помилок в промісах: будь то виклик reject() або помилка, кинута в обробнику за допомогою throw.
// Необхідно розміщувати .catch там, де ми хочемо обробити помилки і знаємо, як це зробити. Обробник може проаналізувати помилку (можуть бути корисні призначені для користувача класи помилок) і прокинути її, якщо нічого не знає про неї (можливо, це програмна помилка).
// Можна і зовсім не використовувати .catch, якщо немає нормального способу відновитися після помилки.
// У будь-якому випадку нам слід використовувати обробник події unhandledrejection (для браузерів і аналог для іншого оточення), щоб відстежувати необроблені помилки і інформувати про них користувача (і, можливо, наш сервер), завдяки чому наш застосунок ніколи не буде “просто помирати”.